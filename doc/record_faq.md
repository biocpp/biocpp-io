# Record FAQ {#record_faq}

Most files in bioinformatics are comprised of *records*, i.e. multiple, indepedent entries that each consist of one or
more *fields*.
For example, a FastA file contains one or more sequence records that each contain an ID field and sequence field.

[TOC]

```
>myseq1
ACGT

>myseq2
GAGGA

>myseq3
ACTA
```

<center>
↓↓↓↓↓↓↓
</center>


| ID field   | sequence field |
|:----------:|:--------------:|
| "myseq1"   | "ACGT"         |
| "myseq2"   | "GAGGA"        |
| "myseq3"   | "ACTA"         |

Each line in this table is conceptionally "a record", and each file is modeled as a series of these records.
The process of "reading a file", is transforming the on-disk representation displayed above into the "abstraction" shown below.
The process of "writing a file" is the reverse.

\note This page contains details on how records are defined. It is meant to provide a better understanding of the design and performance implications. We recommend starting with the snippets shown in the API (e.g. bio::io::seq::reader, bio::io::var::reader, …) and only returning to this page if you have questions or want to fine-tune things.

## What is the full type of my record? {#record_type}

Most records you interact with are produced by readers.

\snippet test/snippet/seq/seq_reader.cpp simple_usage_file

In this example, `rec` is the record and with each iteration of the loop, a new record is generated from the file. The exact type of the record depends on the reader. In the above example, it is:

\snippet test/snippet/seq/seq_reader.cpp simple_usage_file_type

That is quite long and difficulat to remember (even though definitions of X* and Y* are omitted here),
so we write `auto &` instead.

## Does my record own the data? (Shallow vs deep records) {#shallow_vs_deep}

You may have wondered, why std::string_view is used as a type and what these `transform_view`s are.
These imply that the record is a *shallow* data structure, i.e. the fields *appear* like strings or vectors, but they
are implemented more like references or pointers.
See the Core library's documentation for an in-depth \link core_ranges Tutorial on Ranges and Views \endlink.

Shallow records imply fewer memory allocations and/or copy operations during reading. This results in a **better
performance** but also in some important limitations:

* Shallow records cannot be modified (as easily¹).
* Shallow records cannot be "stored"; they depend on internal caches and buffers of the reader and become invalid
as soon as the next record is read from the file.


If you need to change a record in-place and/or "store" the record for longer than one iteration of the reader, you need to use *deep records* instead.
You can tell the reader that you want deep records by providing the respective options:

\snippet test/snippet/seq/seq_reader.cpp options2

This snippet behaves similar to the previous one, except that the type of `rec` is now the following:

\snippet test/snippet/seq/seq_reader.cpp options2_type

This allows you to call std::vector's `.push_back()` member function (which is not possible in the default case).
Creating this kind of record is likely a bit slower than the shallow record.

**Summary**

* The records generated by readers are *shallow* by default.
* This setting has the best performance; but it is less flexible than a *deep* record.
* Readers can be configured to produce *deep* records via the options.

<small>¹ Some modifying operations are possible on views, too, but this depends on the exact types.</small>

## How can I change the field types?

In the previous section, we showed how to change the field types from being shallow to deep.
For some readers, more options are available, e.g. bio::io::seq::reader assumes nucleotide data for the SEQ field by default, but you might want to read protein data instead.

\snippet test/snippet/seq/seq_reader.cpp options

The snippet above illustrates how the alphabet can be changed (and how to provide another option at the same time).

Instead of using these pre-defined record aliases, you can also define them completely manually. You can decide to even read only a subset of the fields by setting some to be ignored::

\snippet test/snippet/seq/seq_reader_options.cpp example_advanced

This code makes FASTA the only legal format and creates records with only the sequence field as a std::string.

But you can also use this mechanism to make some fields shallow and other fields deep. It also allows
to choose different container types.
See the API documentation of the respective `reader_options` for more advanced use-cases and the
exact restrictions on allowed types.

## How can I create record variables?

There are various easy ways to create a record:

1. Use an alias.
2. Deduce from arguments.
3. Use a `tie_record()` function.
4. "Ask" the reader for its record type.

### Record type aliases {#record_aliases}

The record for Sequence I/O is a template:

* bio::io::seq::record (takes three template arguments)

Instead of providing the template arguments yourself, you can choose one of the predefined aliases:

* bio::io::seq::record_dna
* bio::io::seq::record_dna_shallow
* bio::io::seq::record_protein
* bio::io::seq::record_protein_shallow
* bio::io::seq::record_char
* bio::io::seq::record_char_shallow

### Deduce from arguments {#record_type_deduce}

When creating a record from existing variables, C++ can deduce the template arguments for you:

\snippet test/snippet/seq/seq_record.cpp make_record

### Tie from arguments {#record_tie}

When creating a record from existing variables, you can use a `tie_record()` function:

\snippet test/snippet/seq/seq_record.cpp tie_record

This creates a record of references, which is a special kind of shallow record.
It is particularly useful when you have existing data in non-standard formats that you wish to write to disk with a `writer`.

### Ask the reader {#record_type_from_reader}

When iterating over a reader, it is easy to use `auto &` to deduce the record type, but sometimes you need
the record type outside of the for-loop or in a separate context.

This snippet demonstrates how to read an interleaved FastQ file and process the read pairs together (at every second iteration of the loop):

\snippet test/snippet/detail/reader_base.cpp read_pair_processing

To to this, you need to use deep records, because shallow records become invalid after the loop iteration.
Note how it is possible to "ask" the reader for the type of its record to create the local variable.
Here, <tt>decltype(reader)\::record_type</tt> simply deduces to bio::io::seq::record_dna, and it has the same effect as just writing the latter.
